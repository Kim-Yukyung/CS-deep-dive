# 🧠 프로그래밍 언어란?

**CPU**는 0/1로 동작하며 단순한 연산만 수행 가능하지만, 근데 **속도가 겁나 빠름** ㅇㅇ

**기계어**는 CPU가 직접 이해하는 언어 → **사람이 읽고 작성하기 불편**

**어셈블리어**는 기계어의 **기호화 버전**으로, 여전히 저수준 언어(Low-Level Language)이며 **세부 동작을 직접 작성해야 함**

> ex : “물을 먹는다” = 물컵을 찾는다 → 왼손을 뻗는다 → 정수기 버튼을 누른다 → 물이 찰 때까지 기다린다 → 물이 든 컵을 집는다 → 입을 벌린다 → 물을 마신다

---

**고급 언어**는 **인간 친화적 추상화**를 제공 -> 조건문, 반복문, 함수, 재귀 등 사용 가능

**구문 트리(Syntax Tree)** 는 고급 언어로 작성된 프로그램을 **구조적으로 표현한 트리**
  ```c
  if (x > 0) { y = y + 1; }
  ```

**컴파일러**는 **고급 언어 → 구문 트리 분석 → 기계어 변환**

즉, 사람이 작성한 **고급 언어를 CPU가 이해할 수 있는 저수준 언어로 번역**하는 역할

**인터프리터 / 가상 머신**은 **CPU 구조의 차이를 극복**하거나, **즉시 실행을 지원**하기 위한 방식

저수준 언어는 **성능·제어력 ↑**,

고급 언어는 **생산성·이해도 ↑**

→ 따라서 실무에서는 **두 방식을 적절히 섞어 사용**!!!

---

# ⚙️ 컴파일러의 작동 원리

1. **어휘 분석 (Lexical Analysis)**

   * 소스 코드에서 공백·주석을 제거하고 **토큰(Token)** 단위로 쪼갬

     예:
     ```
     int a = 5 + 3;
     → int, a, =, 5, +, 3, ;
     ```

2. **구문 분석 (Syntax Analysis / Parsing 단계)**

   * 토큰을 언어의 **문법 규칙**에 따라 구조적으로 분석
   * **구문 트리(Syntax Tree)** 생성
   * 문법 오류가 있으면 이 단계에서 감지됨

3. **의미 분석 (Semantic Analysis)**

   * 구문상 맞는 문장이 실제로 의미적으로도 올바른지 검사
     (타입 검사, 선언 확인 등)

4. **중간 코드 생성 (Intermediate Representation / IR Code)**

   * 기계어보다는 추상적이지만, 고급 언어보다는 하드웨어 친화적
   * 예: Java → Bytecode

5. **코드 생성 (Code Generation)**

   * IR Code → 어셈블리어 → 기계 명령어 → **대상 파일(Object File)** 생성

---

# 🔗 링커(Linker)

컴파일러는 각 소스 파일을 개별적으로 컴파일하여 **대상 파일(Object File)** 을 생성함

근데 하나의 프로젝트가 여러 소스 파일로 구성될 경우, 여러 개의 대상 파일이 생김

하지만 사용자는 **하나의 실행 파일(Executable)** 을 원함

→ **링커(Linker)** 가 여러 대상 파일을 하나의 실행 파일로 **결합(Link)** 시켜줌

> 📘 비유 : 여러 저자가 쓴 개별 챕터(대상 파일)를 모아 한 권의 책(실행 파일)을 만드는 과정과 유사


### 대상 파일의 구성

1. **코드 영역 (Code Section)** : 명령어(기계어)
2. **데이터 영역 (Data Section)** : 전역 변수, 상수 등
3. **심벌 테이블 (Symbol Table)** : 정의/참조된 모든 심벌 정보

컴파일러는 소스 파일을 컴파일할 때

* 자신이 정의한 심벌 목록
* 외부에서 참조하는 심벌 목록
  을 심벌 테이블에 기록하고 오브젝트 파일에 포함시킴

---

### 링커 주요 기능 ① — 심벌 해석

* **심벌(Symbol)**: 전역 변수와 함수의 이름을 포함하는 모든 식별자
  (지역 변수는 모듈 내에서만 사용되므로 링커의 관심 대상 X)
* 링커는 각 오브젝트 파일의 심벌 테이블을 읽고:

  * 참조된 외부 심벌이 실제 정의되어 있는지 확인
  * 중복 정의 여부를 검사
* 예: `main.c`에서 `printf()` 호출 시, 링커는 표준 라이브러리(`libc`)에서 정의를 찾아 연결함

---

### 링커 주요 기능 ② — 재배치

컴파일 시점에는 변수나 함수의 **실제 메모리 주소를 알 수 없음**
→ 실행 시 프로그램이 메모리에 로드될 때 주소가 달라질 수 있기 때문

**해결 방법**

1. 컴파일러는 주소가 확정되지 않은 부분을 **재배치 테이블(Relocation Table)** 에 기록

   * `.rela.text`: 코드 영역 주소 정보
   * `.rela.data`: 데이터 영역 주소 정보
2. 링커는 이 정보를 참고하여 오브젝트 파일을 하나로 합치며
   **가상 주소(Virtual Address)** 기준으로 실제 주소를 다시 계산·수정함

-> 결과적으로 **모든 코드·데이터 참조가 올바른 주소로 연결됨**

---

### 정적 링크 vs 동적 링크

#### (1) 정적 링크

* 정적 라이브러리: `.a`, `.lib`
* 링커가 실행 파일을 만들 때 **필요한 라이브러리의 코드와 데이터를 실행 파일 안으로 복사함**

**장점**

* 실행 파일이 독립적으로 동작 (외부 의존성 없음)

**단점**

* 여러 프로그램이 동일 라이브러리를 각각 복사 → 디스크 낭비
* 라이브러리 변경 시 모든 실행 파일을 다시 컴파일 해야 함

---

#### (2) 동적 링크

* 동적 라이브러리 = **공유 라이브러리**
* 실행 파일에는 라이브러리의 실제 코드 대신 **참조 정보**(이름, 심벌, 재배치 정보 등)만 포함

**링크 시점**

* **(a) 프로그램이 메모리에 로드될 때**
  동적 링커가 필요한 라이브러리를 탐색 및 적재
* **(b) 프로그램 실행 중 필요할 때**
  라이브러리를 로드 (예: 플러그인 시스템 `dlopen`, `LoadLibrary`)

**장점**

* 메모리·디스크 효율적
* 라이브러리만 교체해도 전체 재컴파일 불필요
* 플러그인 구조, 다언어 연동 가능

**단점**

* 런타임 로드/주소 결정에 따른 성능 저하
* 버전 불일치 등 의존성 문제 발생 가능
* 절대 주소 참조 불가 (가상 주소 기반 참조 필요)

---

### 전체 컴파일 + 링크 흐름

```
소스 파일
 → 어휘 분석 (Lexical Analysis)
 → 구문 분석 (Syntax Analysis)
 → 의미 분석 (Semantic Analysis)
 → 중간 코드 생성 (IR Code)
 → 최적화
 → 코드 생성
 → 어셈블리어 변환
 → 기계어 변환
 → 대상 파일(Object File) 생성
 → 링킹(Linking)
 → 실행 파일 생성
```
