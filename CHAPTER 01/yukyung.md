1. CPU와 기계어

- CPU는 **0과 1**(On/Off)로 이루어진 신호만 이해할 수 있음
- 초기에는 프로그래머가 직접 **이진 코드**(기계어)를 작성해야 했음 
  
```asm 
1101101010011010  
1001001100101001  
1100100011011110  
1011101101010010  
```  
  
-> 사람이 이해하기 너무 어려움 -> 어셈블리어가 등장하게 됨

2. 어셈블리어(Assembly Language)의 등장

```asm
sub $8, %rsp  
mov $.LC0, %edi  
call puts  
mov $0, %eax
```  
  
- 어셈블리어를 **기계어로 번역**하는 프로그램 -> **어셈블러(Assembler)**
- 여전히 저수준 언어라 모든 세부 동작(메모리, 레지스터 등)을 직접 제어해야 함

3. 고수준 언어의 등장
  
- 사람의 사고와 가까운 **추상적인 표현**을 사용해 프로그램 작성 가능
- 예: 조건문, 반복문 등 공통적인 **구문(syntax)** 제공 

```asm
if: if expr statement else statement  
for: while expr statement  
statement: if | for | statement
```

-> 하지만 CPU는 여전히 기계어만 이해 -> 변환 과정 필요!

4. 구문 트리와 컴파일러의 등장

  - **컴퓨터는 코드를 트리 형태**로 분석할 수 있음 -> **구문 트리**
  - 리프 노드(leaf node)를 기계어를 번역 -> 부모 노드에 반영 -> 전체 프로그램을 기계어로 변환

-> **이 역할을 하는 프로그램이 바로 컴파일러**

5. 컴파일러의 정의

- 컴파일러는 고수준 언어를 저수준 언어(기계어)로 번역하는 프로그램

6. 컴파일러의 동작 과정

(1) 어휘 분석 (Lexical Analysis)

- 소스 코드에서 **토큰(Token)** 추출
- 예: `- while (x < 10) { ... }` -> `- - while, (, x, <, 10, ), {, ..., }`

(2) 구문 분석 (Parsing)

- 추출한 토큰들이 **문법에 맞게 배치되었는지 확인**
- 올바르다면 구문 트리 생성, 아니면 문법 오류 발생

(3) 의미 분석 (Semantic Analysis)

- 구문은 맞지만 **의미가 맞는지 확인**
- 예: 정수형 변수와 문자열을 더하는 오류 등

(4) 중간 코드 생성 (IR Code)

- 구문 트리를 기반으로 **중간 코드(Intermediate Representation, IR)** 생성
- CPU에 바로 전달하기 전, 더 최적화된 중간 표현 단계

(5) 코드 생성 
- IR -> 어셈블리어 -> 기계어 반환

7. 링커(Linker)와 링크 과정

(1) 대상 파일(Object File) 생성

- 소스 파일 하나당 **대상 파일(.o)** 하나씩 생성
- 예: 소스 파일 3개 -> 대상 파일 3개

(2) 링커의 역할 

- 여러 대상 파일을 하나의 실행 파일로 합침
- 주요 기능
	- 심벌 해석 (Symbol Resolution): 전역 변수, 함수 이름 등 외부 참조를 연결
	- 재배치 (Relocation): 실제 메로리 주소로 치환, 컴파일 시점에는 함수 위치를 정확히 알 수 없으므로 링크 단계에서 주소 확정

8. 정적 링크 vs 동적 링크

(1) 정적 링크 (Static Linking)

정의

- 정적 라이브러리를 실행 파일에 직접 포함하여 하나의 완전한 실행 파일을 생성하는 방식
- 정적 라이브러리는 .lib(Windows) 또는 .a(Linux) 형태로 제공됨

동작 과정

- 라이브러리를 별도로 컴파일 → 여러 개의 오브젝트 파일을 하나의 패키지로 묶음
- 이때 헤더 파일(.h)을 함께 제공하여 함수 선언을 노출
- 자신의 코드만 컴파일 후, 미리 컴파일된 정적 라이브러리를 링커가 실행 파일에 복사

(2) 동적 링크

정의

- 라이브러리를 실행 파일에 직접 포함하지 않고, 필요 시 외부에서 불러와 사용
- 동적 라이브러리(Shared Library) 라고도 하며, .dll(Windows) 또는 .so(Linux) 형태로 제공됨

동작 과정

- 실행 파일에는 라이브러리 코드 자체가 포함되지 않음
- 대신, 라이브러리 이름, 심벌 테이블, 재배치 정보 등 필수 정보만 기록
- 프로그램이 실행될 때, 운영체제가 동적 링커(Dynamic Linker)를 통해 실제 라이브러리 파일을 메모리에 적재하고 연결
