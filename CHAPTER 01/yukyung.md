### 1. CPU와 기계어

- CPU는 **0과 1**(On/Off)로 이루어진 신호만 이해할 수 있음
- 초기에는 프로그래머가 직접 **이진 코드**(기계어)를 작성해야 했음 
  
```asm 
1101101010011010  
1001001100101001  
1100100011011110  
1011101101010010  
```  
  
-> 사람이 이해하기 너무 어려움 

<br>

### 2. 어셈블리어(Assembly Language)의 등장

```asm
sub $8, %rsp  
mov $.LC0, %edi  
call puts  
mov $0, %eax
```  
  
- 기계어와 해당 특정 작업을 간단하게 대응시켜 기계어를 인간이 읽고 이해할 수 있는 단어와 대응
- 어셈블리어를 **기계어로 번역**하는 프로그램 -> **어셈블러(Assembler)**
- 여전히 저수준 언어라 모든 세부 동작(메모리, 레지스터 등)을 직접 제어해야 함

<br>

### 3. 고수준 언어의 등장
  
- 사람의 사고와 가까운 **추상적인 표현**을 사용해 프로그램 작성 가능
- 예: 조건문, 반복문 등 공통적인 **구문(syntax)** 제공 

```asm
if: if expr statement else statement  
for: while expr statement  
statement: if | for | statement
```

-> 하지만 CPU는 여전히 기계어만 이해 -> 변환 과정 필요!

<br>

### 4. 구문 트리와 컴파일러의 등장

  - **컴퓨터는 코드를 트리 형태**로 분석할 수 있음 -> **구문 트리**
  - 리프 노드(leaf node)를 기계어를 번역 -> 부모 노드에 반영 -> 전체 프로그램을 기계어로 변환

<img width="693" height="504" alt="image" src="https://github.com/user-attachments/assets/889e2b92-060b-464c-8b7c-c48e92afb4cc" />

-> **이 역할을 하는 프로그램이 바로 컴파일러!**

-> 컴파일러는 고수준 언어를 저수준 언어(기계어)로 번역하는 프로그램

<br>

### 5. 컴파일러의 동작 과정

(1) 어휘 분석 (Lexical Analysis)

- 소스 코드에서 **토큰(Token)** 추출
- 예: `while (x < 10) { ... }` -> `while, (, x, <, 10, ), {, ..., }`

(2) 구문 분석 (Parsing)

- 추출한 토큰들이 **문법에 맞게 배치되었는지 확인**
- 올바르다면 구문 트리 생성, 아니면 문법 오류 발생

(3) 의미 분석 (Semantic Analysis)

- 구문은 맞지만 **의미가 맞는지 확인**
- 예: 정수형 변수와 문자열을 더하는 오류 등

(4) 중간 코드 생성 (IR Code)

- 구문 트리를 기반으로 **중간 코드(Intermediate Representation, IR)** 생성
- CPU에 바로 전달하기 전, 더 최적화된 중간 표현 단계

(5) 코드 생성 
- IR -> 어셈블리어 -> 기계어 반환

<br>

### 6. 링커(Linker)와 링크 과정

(1) 대상 파일(Object File) 생성

- 컴파일 과정을 거치면 소스 파일 하나당 **대상 파일(.o)** 하나씩 생성
- 예: 소스 파일 3개 -> 대상 파일 3개

(2) 링커의 역할 

- 여러 대상 파일을 하나의 실행 파일로 합침
- 주요 기능

	- 심벌 해석 (Symbol Resolution): 전역 변수, 함수 이름 등 외부 참조를 연결
	- 재배치 (Relocation): 실제 메로리 주소로 치환, 컴파일 시점에는 함수 위치를 정확히 알 수 없으므로 링크 단계에서 주소 확정

<br>

### 7. 정적 링크 vs 동적 링크

**(1) 정적 링크**

정의

- 정적 라이브러리를 실행 파일에 직접 포함하여 하나의 완전한 실행 파일을 생성하는 방식
- 정적 라이브러리는 .lib(Windows) 또는 .a(Linux) 형태로 제공됨

동작 과정

- 라이브러리를 별도로 컴파일 → 여러 개의 오브젝트 파일을 하나의 패키지로 묶음
- 이때 헤더 파일(.h)을 함께 제공하여 함수 선언을 노출
- 자신의 코드만 컴파일 후, 미리 컴파일된 정적 라이브러리를 링커가 실행 파일에 복사

**(2) 동적 링크**

정의

- 라이브러리를 실행 파일에 직접 포함하지 않고, 필요 시 외부에서 불러와 사용
- 실행 파일에는 라이브러리 이름, 심벌 테이블, 재배치 정보 등 필수 정보만 기록
- 동적 라이브러리(Shared Library) 라고도 하며, .dll(Windows) 또는 .so(Linux) 형태로 제공됨

동작 과정

(1) 프로그램 로딩 시

- 실행 파일이 메모리에 적재됨
- 동적 링커가 실행되어 실행 파일에 필요한 라이브러리를 탐색
- 라이브러리의 위치와 심벌 정보를 확인하고, 필요한 주소를 연결하여 프로그램 완성

(2) 프로그램 실행 시

- 코드 실행 도중 특정 시점에 라이브러리를 동적으로 로드

<br>

### 8. 재배치

컴파일 시점에는 변수와 함수의 실제 메모리 주소를 알 수 없음

-> 프로그램이 실행되기 전까지 프로세스의 메모리 레이아웃이 확정되지 않기 때문

**해결 방법**

1.	컴파일러는 확정되지 않은 주소를 발견할 때, 해당 정보를 재배치 테이블에 기록
		.rela.text: 명령어(코드)와 관련된 주소 정보
		.rela.data: 데이터와 관련된 주소 정보
2. 실행 파일이 로딩될 때, 링커가 가상 메모리 주소를 기준으로 실제 메모리 주소를 계산하고 수정

 -> 프로그램이 실행되면서 올바른 주소로 연결 가능

**가상 메모리의 역할**

- 프로그램은 자신이 시스템의 모든 메모리를 독점적으로 사용하는 것처럼 인식
- 실제 물리 메모리 위치와는 무관하게 가상 주소를 사용

-> 링커는 프로그램 실행 전에도 예측 가능한 메모리 구조를 기반으로 심벌 주소를 결정할 수 있음
