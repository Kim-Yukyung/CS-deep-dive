### 📘 학습 내용

CPU는 메모리 없이 동작이 불가능

- 메모리는 0,1을 저장할 수 있는 사물함
- 여행의 세 번째 역이라는 표현은 진짜 잘못지음

메모리에서 파생된 개념 → 바이트, 구조체, 객체, 변수, 포인터, 참조

메모리 셀 = 사물함

사물함에 보관되는 0, 1이 1비트라고 함

8개 사물함에 번호를 붙이면 바이트가 되는거임

4바이트를 묶어 하나의 정수를 표현하는 단위로 사용

12바이트를 묶은게 객체 또는 구조체

ex) store 1 6 ⇒ 하나는 저장할 숫자 값 뒤에는 사물함 번호

만약에 모호한 경우 기호를 붙여서 판단 ex) $

주소 6에 숫자 1를 저장 주소 6을 a로 부르는것 별칭 느낌으로 판단

a변수는 2가지 뜻

- 값이 1
- 메모리 주소 n에 저장

만약 b변수가 a를 가리키고 있다면 따로 메모리 할당이 필요없기 때문에  복사본을 만들 필요가 없다

변수가 값뿐 아니라 메모리 주소까지 저장할 수 있게 되면서 포인터가 탄생

⇒포인터는 메모리 주소를 추상화 한 것

주소1에 3이 들어있따고 가정

주소1→주소3→데이터

⇒간접 주소 지정

C언어는 메모리 주소를 추상화 하지 않으면 메모리 주소를 프로그래머가 직접 알 수 있지만

자바나 파이썬 같은건 저장할 수 있는 것처럼 보이는 거고 C언어가 진또배기

BUT, 포인터에서 한번 더 추상화 한 것이 참조

나훈아 태진아~

태진이의 구체적인 위치를 딱 이야기해서 말했다면 그 위치가 곧 포인터가 되는것

메모리의 모든 프로세스 주소공간에는 코드영역 데이터 영역 힙 영역 스택 영역

- 코드 영역 & 데이터 영역⇒ 실행파일을 초기화할 때 생성
- 힙 영역 ⇒ 동적 메모리 할 당(malloc 함수에서 요청한 메모리가 할당)
- 스택 영역⇒ 함수호출에 사용, 매개변수, 반환 주소, 레지스터 정보 등을 포함
- 유휴 영역 ⇒ 있었던 것 같은데 이따가 확인

모든 프로세스 코드 영역 = 0x400000에서 시작

저런 메모리 주소는 가짜 주소고 메모리에 조작이 일어나기 전 실제 물리 메모리 주소로 변경

가상 메모리와 물리 메모리 사이의 mapping 관계가 페이지테이블의 존재 이유

관계 유지하는 것을 페이지 테이블 각 프로세스에는 단한개의 페이지 테이블만 존재

프로세스의 주소 공간을 동일한 크기 조각으로 쪼갬 ⇒ 조각은 페이지

결국 그림과 같이 표현하는건 그냥 편의성을 위해 임의로 그린 것

퀘스트에 비유 한 것을 완료궤적으로 쭉 나열하면 결국 스택 ⇒ LIFO가 된다

프로세스 스택 영역의 높은 주소가 맨 위에 있고 스택 영역은 낮은 주소 방향으로 커짐

위에서 아래로 쌓이는 거

CPU에 함수 A에서 함수 B로 점프해서 명령어 실행 뭐 이런거 어떻게 획득하고 유지하냐

스택 프레임의 도움이 필요

CALL 명령어 이후에 위치한 주소를 함수 A의 스택 프레임에 집어 넣음

크키가 하단으로 커진다.

결국 주소를 저장하고 있다가 반환해서 원래 함수로 간다.

함수 A가 함수 B를 호출한다면 함수 A가 매개변수를 레지스터에 저장 함수 B가 레지스터에서 매개변수 얻어서 사용 반환값도 마찬가지로 레지스터에 저장하고 함수 B 완료되면 다시 가져옴

매개변수 수>레지스터 수 ⇒ 나머지는 스택 프레임에 집어 넣음 → 얘는 만능인가?

레지스터는 CPU의 내부 리소스 ⇒ 뭔말이여?

이것이 문제되지는 않을까요? ⇒ 문제 되니까 물어봤겠지…

레지스터에 지역 변수를 저장하기 전 원래 저장되었던 초기값을 잠깐 딴데에 두었다 레지스터 사용 종료 후 다시 초깃값 들고와야 함 ⇒ 그 초깃값도 스택프레임에 저장 → 만능이 맞는 것 같다.

스택영역에는 크기 제한이 있음 ⇒ Stackoverflow~~

1. 너무 큰 지역 변수를 만들지 말자
2. 함수 호출 단계가 너무 많으면 안된다.

스택 영역 아래는 유휴영역이 존재

### 모든 함수는 각자만의 스택 프레임이 있다.

228쪽 코드를 참고하자.

특정 데이터를 여러 함수에 걸쳐 사용해야 한다면 프로그래머가 완전히 직접 제어할 수 있는 큰 메모리 영역 즉 힙 영역에서 할당 해제 해야함

힙 영여기은 커다란 배열 형태

메모리가 긴 주차장

- 메모리 요청은 입차
- 메모리 반환은 출차

- 메모리 할당할때는 해당 메모리 조각이 비어있는지 알려주는 설정값
- 해당 메모리 조각의 크기를 기록한 숫자의 정보만 있으면 된다

헤더의 32bit 중 1비트는 비어있는지 할당되어있는지 판단하는 불린?

31비트는 조각 크기

할당 가능한 메모리 조각이 페이로드(payload)

malloc을 호출하면 반환되는 메모리 주소가 바로 여기서 시작

메모리 할당할 때 적절한 크기와 여유 메모리 조각을 찾아야 함 

**전략**

1. 최초 적합 방식 ⇒ 가장 먼저 발견된 요구 사항을 만족하는 항목 반환 → 단순 하지만 멍청멍청
2. 다음 적합 방식 ⇒ 커누스모리스프랫 알고리즘…? → 이론적으로 최초적합 방식 보다 빠름
3. 최적 적합 방식 ⇒ 모다 탐색 후에 요구 사항을 만족하는 것 반환 → 좀 느림 굼벵이

메모리가 한번 할당 되면 남는거는 내부 단편화가 발생해서 남는 부분을 사용할 방법이 없음

메모리 할당을 해제 한 후에는 여유 메모리 조각에 대해 더 큰 메모리 조각으로 서로 병합 하는 것이 좋다?

⇒ 너무 자원이 많이 소모

헤더랑 푸터에 인접한 정보를 가지고 양방향 연결 리스트로 만들어서 병합한다

---

## 정리

- CPU는 **메모리에 저장된 데이터를 기반으로만 동작 가능**하며, 메모리는 0과 1(비트)을 저장하는 구조이다.
- **비트(bit)** = 0 또는 1을 저장하는 최소 단위 → **8비트 = 1바이트(byte)**.
- 일반적으로 **4바이트 = 32비트 정수형 (int)**, **12바이트 정도라면 구조체/객체 단위**로 사용되기도 한다.
- 변수는 반드시 **값 + 그 값을 저장한 메모리 주소를 동시에 의미**한다.
    
    → 그래서 `b가 a를 가리킨다 = 값 복사 없이 a의 주소만 참조한다` → 이것이 **포인터(pointer)** 개념.
    
- 포인터는 **메모리 주소를 직접 다루는 개념**, 그리고 그보다 더 추상화된 방식이 **참조(reference)** 개념이다. (Java/Python 방식)
- 프로그램이 실행되면 **코드 영역, 데이터 영역, 힙(Heap), 스택(Stack)** 이라는 구조로 메모리가 분할된다.
    - **코드 영역 / 데이터 영역** = 프로그램이 실행될 때 이미 메모리에 올라옴
    - **힙 영역** = 프로그래머가 `malloc`, `new` 등으로 직접 메모리 할당/해제
    - **스택 영역** = 함수 호출 시 자동으로 생성/제거되는 영역 (매개변수, 지역변수, 복귀 주소 등 저장)
    - 스택은 **LIFO 구조**, 메모리 주소가 **높은 → 낮은 방향으로 쌓이는 것**이 특징
- **스택 프레임(stack frame)** 이 함수 호출/복귀를 정확하게 추적하기 위해 사용되는 구조이며, 호출 시점의 복귀 주소와 레지스터 값 등을 저장해두었다가 함수가 끝나면 복원한다.
- 스택은 **크기 제한**이 있기 때문에
    
    → 너무 큰 배열/객체를 지역변수로 선언하거나
    
    → 너무 깊은 재귀 함수 호출 등은 **Stack Overflow** 발생 가능
    
- 반대로, 힙은 **크기가 크고 수동 관리**이기 때문에 여러 함수에서 공통 데이터 공유가 가능하다.
    
    → 대신, 할당과 해제 타이밍은 프로그래머가 직접 관리해야 하고, **단편화(fragmentation)** 문제가 생길 수 있다.
    
- **힙 메모리 할당 전략**
    1. 최초 적합 (First-fit) → 빠르지만 효율성 낮음
    2. 다음 적합 (Next-fit) → First-fit 개선 버전
    3. 최적 적합 (Best-fit) → 가장 잘 맞는 조각 선택 (효율적이나 느림)
- 메모리를 반환할 때는, **인접한 빈 메모리 조각끼리 병합(coalescing)** 하는 것이 좋지만, 이 과정에도 연산 비용이 든다.
    

    → 그래서 헤더/푸터 기반의 **양방향 연결 리스트 형태로 메모리 블록 상태를 추적**한다.

---

## 예상 질문
1. 스택(Stack)과 힙(Heap)의 차이를 설명해보세요.

→ 메모리 구조 이해 + 함수 호출 + 동적 메모리 + 포인터/참조까지 이어서

2. 포인터와 참조(Reference)의 차이는 무엇인가요?

→ C언어 vs Java/Python 언어적 차이 + 메모리 직접 접근의 위험성
