# 3-1장 ~ 3-4장
## 정리

- CPU는 **메모리에 저장된 데이터를 기반으로만 동작 가능**하며, 메모리는 0과 1(비트)을 저장하는 구조이다.
- **비트(bit)** = 0 또는 1을 저장하는 최소 단위 → **8비트 = 1바이트(byte)**.
- 일반적으로 **4바이트 = 32비트 정수형 (int)**, **12바이트 정도라면 구조체/객체 단위**로 사용되기도 한다.
- 변수는 반드시 **값 + 그 값을 저장한 메모리 주소를 동시에 의미**한다.
    
    → 그래서 `b가 a를 가리킨다 = 값 복사 없이 a의 주소만 참조한다` → 이것이 **포인터(pointer)** 개념.
    
- 포인터는 **메모리 주소를 직접 다루는 개념**, 그리고 그보다 더 추상화된 방식이 **참조(reference)** 개념이다. (Java/Python 방식)
- 프로그램이 실행되면 **코드 영역, 데이터 영역, 힙(Heap), 스택(Stack)** 이라는 구조로 메모리가 분할된다.
    - **코드 영역 / 데이터 영역** = 프로그램이 실행될 때 이미 메모리에 올라옴
    - **힙 영역** = 프로그래머가 `malloc`, `new` 등으로 직접 메모리 할당/해제
    - **스택 영역** = 함수 호출 시 자동으로 생성/제거되는 영역 (매개변수, 지역변수, 복귀 주소 등 저장)
    - 스택은 **LIFO 구조**, 메모리 주소가 **높은 → 낮은 방향으로 쌓이는 것**이 특징
- **스택 프레임(stack frame)** 이 함수 호출/복귀를 정확하게 추적하기 위해 사용되는 구조이며, 호출 시점의 복귀 주소와 레지스터 값 등을 저장해두었다가 함수가 끝나면 복원한다.
- 스택은 **크기 제한**이 있기 때문에
    
    → 너무 큰 배열/객체를 지역변수로 선언하거나
    
    → 너무 깊은 재귀 함수 호출 등은 **Stack Overflow** 발생 가능
    
- 반대로, 힙은 **크기가 크고 수동 관리**이기 때문에 여러 함수에서 공통 데이터 공유가 가능하다.
    
    → 대신, 할당과 해제 타이밍은 프로그래머가 직접 관리해야 하고, **단편화(fragmentation)** 문제가 생길 수 있다.
    
- **힙 메모리 할당 전략**
    1. 최초 적합 (First-fit) → 빠르지만 효율성 낮음
    2. 다음 적합 (Next-fit) → First-fit 개선 버전
    3. 최적 적합 (Best-fit) → 가장 잘 맞는 조각 선택 (효율적이나 느림)
- 메모리를 반환할 때는, **인접한 빈 메모리 조각끼리 병합(coalescing)** 하는 것이 좋지만, 이 과정에도 연산 비용이 든다.
    

    → 그래서 헤더/푸터 기반의 **양방향 연결 리스트 형태로 메모리 블록 상태를 추적**한다.

---

## 예상 질문
1. 스택(Stack)과 힙(Heap)의 차이를 설명해보세요.

→ 메모리 구조 이해 + 함수 호출 + 동적 메모리 + 포인터/참조까지 이어서

2. 포인터와 참조(Reference)의 차이는 무엇인가요?

→ C언어 vs Java/Python 언어적 차이 + 메모리 직접 접근의 위험성

