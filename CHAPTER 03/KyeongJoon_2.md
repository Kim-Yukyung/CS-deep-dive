# 3-5장 ~ 3-9장
## 1) 핵심 개념 한눈에

- **특권(Privilege) 레벨**: CPU는 여러 권한 레벨(예: 0,1,2,3)을 제공. 숫자가 작을수록 권한이 큼. 보통
    - 0: **커널 모드**(운영체제 코드 실행, 모든 자원 접근 가능)
    - 3: **사용자 모드**(일반 애플리케이션)
- **시스템 콜**: 사용자 코드가 커널 기능(디바이스, 메모리 관리 등)을 쓰려면 시스템 콜(특정 기계 명령)을 통해 권한 전환.
- **가상 메모리 vs 물리 메모리**: 프로세스는 가상 주소를 사용. 실제 물리 메모리는 페이지 단위로 매핑되고, 필요 시에만 물리 페이지가 할당됨(수요 할당).

---

## 2) 메모리 할당(일반적인 흐름, 단계별)

1. 애플리케이션이 `malloc(size)` 호출.
2. 표준 라이브러리(유저 레벨)가 내부 자유 블록(빈 공간)을 찾아봄.
3. 충분한 블록이 없으면: 라이브러리는 **brk/sbrk** 또는 `mmap` 같은 커널 인터페이스를 호출해 힙(가상 메모리 영역)을 확장.
    - 이 호출은 **커널 모드**로 전환되어 처리됨.
    - 이때 확장되는 건 *가상 주소 공간*에 대한 변경.
4. `malloc`이 가상 주소에서 블록 반환(사용자 모드로 돌아옴).
5. 프로그램이 실제로 그 메모리(쓰기/읽기)를 사용하면,
    - 해당 가상페이지에 물리 메모리가 아직 연결되어 있지 않다면 **페이지 폴트(페이지 누락)** 발생.
    - 커널이 중재자 역할을 하고 물리 페이지를 할당한 뒤(또는 스왑에서 로드), 페이지 테이블을 갱신하고 사용자 모드로 복귀.
6. 결과: 가상 주소는 즉시 얻지만, **물리 메모리의 실제 확보는 액세스 시점(수요할당)**에 일어날 수 있음.

---

## 3) `malloc` vs 메모리 풀 (메모리 관리 전략)

- **malloc (표준 라이브러리)**
    - 범용적, 편의성 높음. 다양한 크기 요청을 처리. 내부적으로는 빈 블록 관리(프리 리스트 등), coalescing, binning 등 복잡한 로직을 가짐.
    - 단점: 성능/파편화, 다중 스레드에서 잠금 경쟁 가능.
- **메모리 풀 (Memory Pool, 응용 레벨)**
    - 특정 패턴(동일 크기 반복 할당/해제)에 최적화. 미리 큰 덩어리(큰 블록)를 요청해서 내부에서 고속 분배. 보통 연결 리스트로 빈 슬롯 관리.
    - 장점: 성능 우수, 낮은 단편화(특정 패턴에 대해).
    - 단점: 범용성 낮음, 복잡한 메모리 생명주기 관리, 스레드 안전성 문제.

---

## 4) 스레드 환경에서 메모리 풀의 문제와 해결 아이디어

문제: 스레드 A에서 할당된 메모리를 스레드 B가 해제해야 할 경우(또는 반대) — 교차 해제(cross-thread free) 발생 시 안전성 보장 필요.

해결(대표적 방법들):

- **글로벌 락(간단)**: 모든 해제/할당 시 락을 걸기 — 안전하지만 성능 저하.
- **스레드 로컬 풀 + 중앙 대기열**:
    - 각 스레드는 자신의 로컬 풀을 사용해 빠르게 할당.
    - 교차 해제는 *스레드 안전한 중앙 큐(또는 lock-free 큐)*에 넣고, 원 소유 스레드가 주기적으로 회수(reclaim)한다.
- **참조 계수 / GC(간단형)**: 참조 카운팅으로 소유권 관리(오버헤드 있음).
- **지연 해제(Deferred reclamation)**: epoch-based reclamation, hazard pointers 같은 기법 사용 — 고성능 동시성 환경에서 많이 쓰임(구현 복잡).
- **단일 소유권 규칙(디자인)**: 가능하면 할당한 스레드가 해제하도록 설계(가장 단순하고 안전).

짧은 권장안: 성능 요구가 낮거나 중간 정도면 스레드-로컬 풀 + 중앙 큐 방식이 균형 좋음. 초고성능/락프리 필요하면 epoch/hazard pointer 고려.

---

## 5) 가상 메모리 & 페이지 폴트(중요 포인트)

- 가상 주소는 즉시 반환될 수 있으나, 물리 페이지는 **실제 접근 시(페이지 폴트)** 할당될 수 있다.
- 페이지 폴트는 인터럽트 → 커널 전환 → 물리 페이지 할당/매핑 → 사용자 모드 복귀 과정.
- 이 때문에 메모리 요청이 빨리 끝나더라도 실제 성능 저하는 액세스 시점에서 발생할 수 있음.

---

## 6) 흔한 메모리 버그 (체크리스트) — 핵심만

- **지역 변수 포인터 반환** → 스택 프레임이 사라져 유효하지 않은 주소 참조.
- **포인터 산술(연산) 오해** → `ptr + 1`은 바이트 1이 아니라 타입 크기만큼 이동.
- **초기화되지 않은 메모리 읽기** → 보안/불확정 동작. `malloc`은 0으로 초기화해주지 않음(반면 `calloc`은 0 초기화).
- **이미 해제된 메모리(dangling pointer) 참조** → 예측 불가 동작, 크래시 가능.
- **배열 범위 초과 접근** → 다른 데이터 파괴, 보안 취약점(버퍼 오버플로우).
- **스택 오버플로우** → 재귀 깊음/큰 지역 배열로 인해 인접 스택 프레임 파괴.
- **메모리 누수** → 할당만 하고 해제 누락 → 장시간 동작 시 힙 점유 증가.

검사 팁: 정적 분석 도구, ASAN(주소 상속기), valgrind 같은 도구 사용 추천.

---

## 7) SSD는 왜 RAM 대체가 안 되는가 (핵심)

- **접근 단위 & 지연**: RAM은 바이트 단위 읽기/쓰기(낮은 레이턴시), SSD는 블록(혹은 페이지/섹터) 단위로 동작하고 지연이 크다.
- **쓰기 수명**: SSD는 플래시 셀의 쓰기 횟수 한계가 있어 빈번한 쓰기는 수명 단축.
- **세부 동작 차이**: RAM은 휘발성(전원 꺼지면 값 사라짐), SSD는 비휘발성. 메모리 계층에서 요구하는 매우 짧은 레이턴시·무제한 쓰기 특성에 맞지 않음.

→ 그래서 캐시 계층(예: 디스크 캐시)으로는 쓰지만 메인 메모리(RAM) 대체는 부적합.

---

## 8) 실전 적용(요약·팁)

- **개발자 관점**: `malloc`과 같은 표준 라이브러리는 편리하지만, 성능이나 패턴이 고정된 경우 메모리 풀로 최적화 가능.
- **디버깅**: 초기화 여부·해제 이후 참조·배열 범위만 항상 체크하면 많은 버그 예방 가능.
- **멀티스레드**: 교차 해제 상황을 미리 설계(소유권 규칙 또는 안전한 회수 메커니즘)하지 않으면 골치 아픔.
- **성능 관찰**: 가상 메모리→물리 메모리 매핑(페이지 폴트) 비용을 염두에 두고, 큰 메모리 블록을 미리 접근(touch)해 물리 할당을 강제할 수도 있음(단, 신중히).

---

## 9) 3줄 요약 (끝맺음)

- 운영체제는 권한 레벨을 통해 사용자 코드와 커널 코드를 분리하고, 메모리는 가상 주소에서 필요한 시점에 물리 페이지로 연결된다.
- `malloc`은 편리하지만, 성능/스레드 이슈 때문에 고성능 환경에선 **메모리 풀** 같은 사용자 레벨 전략을 쓴다.
- 포인터, 초기화, 해제 관리, 스레드 소유권을 조심하면 대부분의 메모리 버그를 피할 수 있다.
