## CHAPTER 04 — CPU와 기계어: 트랜지스터에서 분기 예측까지

### 1. 트랜지스터와 논리 게이트의 개념

컴퓨터의 본질은 스위치 구조.

트랜지스터는 스위치 제어를 위한 전자 소자이며, 현대 컴퓨터 아키텍처의 기초 요소.

- 두 스위치가 모두 켜진 상태에서 전류가 흐르는 구조 → **논리곱(AND)**
- 하나라도 켜져 있을 때 전류가 흐르는 구조 → **논리합(OR)**
- 스위치를 닫을 때 전류가 흐르고, 열면 전류가 차단되는 구조 → **논리부정(NOT)**

이 세 가지 게이트를 조합하여 모든 논리식을 구성할 수 있는 성질을 **논리적 완전성(Logical Completeness)**이라 부름.

---

### 2. CPU와 이진 연산의 구조

CPU가 인식하는 데이터는 0과 1의 이진 값.

모든 연산은 이진 덧셈 구조를 기반으로 동작.

| 연산 | 결과 | 자리올림 |
| --- | --- | --- |
| 0 + 0 | 0 | 0 |
| 0 + 1 | 1 | 0 |
| 1 + 0 | 1 | 0 |
| 1 + 1 | 0 | 1 |

자리올림 발생으로 인해 ‘1 + 1 = 0’ 결과가 생성되는 구조.

이 원리를 물리적으로 구현한 회로가 **가산기(Adder)** 구조이며,

내부에는 **배타적 논리합(XOR)** 게이트가 포함된 형태.

---

### 3. 정보 저장 회로의 구조

연산 회로는 데이터 저장 기능이 없기 때문에,

정보를 유지하기 위한 별도의 회로가 필요한 구조.

부정 논리곱 게이트(NAND) 두 개를 조합하여 구성된 **SR 래치(SR Latch)**가 그 예시.

- S 단자: Set 신호 입력
- R 단자: Reset 신호 입력

SR 래치를 확장한 형태가 **레지스터(Register)** 구조이며,

이는 CPU 내부에서 임시 데이터를 저장하기 위한 장치.

주소 지정 기능을 위해 여러 레지스터를 조합한 복합 회로 구조가 사용됨.

---

### 4. 명령어 집합의 구조

CPU는 스스로 연산 절차를 결정하지 않으며,

**기계 명령어(Machine Instruction)**라는 실행 규칙을 통해 동작하는 구조.

CPU가 이해할 수 있는 명령어들의 모음이 **명령어 집합(ISA, Instruction Set Architecture)** 구조이며,

이는 소프트웨어와 하드웨어가 상호작용하는 인터페이스 계층.

> 하드웨어 ↔ 명령어 집합 ↔ 소프트웨어
> 
> 
> 명령어 집합은 두 영역을 연결하는 경계 구조.
> 

---

### 5. 클럭 신호의 개념

CPU 동작은 일정한 주기로 이루어지며, 이 주기를 제어하는 신호가 **클럭 신호(Clock Signal)** 구조.

- 클럭 한 주기당 명령어 한 단계 실행 구조
- 주파수(Hz)가 높을수록 단위 시간당 더 많은 연산 수행 구조

클럭 신호 하에서 산술 논리 장치(ALU), 레지스터, 제어 장치가 동기적으로 작동하며,

이 구성 요소들을 통합한 장치가 **중앙처리장치(CPU, Processor)** 구조.

---

### 6. 유휴 상태와 스케줄링의 구조

운영체제는 실행 중인 프로그램을 **프로세스(Process)** 단위로 관리하는 구조.

스케줄러(Scheduler)는 우선순위를 기반으로 프로세스 실행 순서를 제어하는 시스템.

실행 가능한 프로세스가 없을 때 운영체제는 **유휴 프로세스(Idle Process)**를 실행하는 구조.

유휴 프로세스는 실제 연산을 수행하지 않고, 내부적으로 **halt 명령어**를 실행해 전력 소비를 최소화하는 구조.

`halt` 명령어는 **특권 명령어(Privileged Instruction)**로, 커널 모드에서만 실행 가능한 형태.

CPU는 타이머 인터럽트를 통해 주기적으로 깨어나며,

무한 루프 기반의 순환 구조를 유지하면서도 효율적인 대기 상태를 보장하는 구조.

이러한 설계를 “우아한 구조”라고 표현.

---

### 7. 음수 표현 방식의 구조

컴퓨터는 2진 위치 기수법을 사용하며, 최상위 비트(MSB)를 부호 비트로 사용하는 구조.

- 0 → 양수
- 1 → 음수

### 부호-크기(Sign-Magnitude) 방식

양수와 음수를 별도의 부호 비트로 구분하는 표현 구조.

### 1의 보수(One’s Complement) 방식

모든 비트를 반전시켜 음수를 표현하는 구조.

### 2의 보수(Two’s Complement) 방식

1의 보수에 1을 더해 음수를 표현하는 구조.

2의 보수 방식을 사용하면 부호와 관계없이 동일한 회로로 연산이 가능하며,

현대 CPU에서 표준으로 채택된 표현 구조.

---

### 8. CPU 연산 단계와 파이프라인의 구조

CPU는 명령어를 다음 네 단계로 처리하는 구조.

1. 명령어 인출(Fetch)
2. 명령어 해독(Decode)
3. 명령어 실행(Execute)
4. 결과 저장(Write-back)

이 과정은 산업 공정의 조립 라인과 유사한 구조이며,

동시에 여러 명령어를 처리하는 **파이프라인(Pipeline)** 기술을 통해 성능을 극대화하는 구조.

---

### 9. 분기 예측의 구조

`if` 문과 같은 조건 분기는 **조건부 점프 명령어(Conditional Jump)**로 변환되는 구조.

CPU는 조건 평가 전에 결과를 예측해 다음 명령어를 미리 실행하는 **분기 예측(Branch Prediction)** 구조를 사용함.

- 예측 성공 시 → 파이프라인 유지, 성능 향상 구조
- 예측 실패 시 → 파이프라인 플러시 발생, 성능 저하 구조

데이터가 정렬되어 있을 경우 예측이 규칙적으로 이루어지고,

무작위일 경우 CPU의 예측 정확도가 낮아지는 구조.

이로 인해 매크로나 분기 최소화 기법 같은 소프트웨어 수준의 최적화가

하드웨어 효율과 직접적으로 연결되는 구조.

---

### 10. 핵심 요약

| 핵심 요소 | 설명 |
| --- | --- |
| 트랜지스터 | 스위치 역할, 논리 게이트 구성의 기본 단위 |
| 논리 게이트 | AND / OR / NOT 조합을 통한 논리식 표현 구조 |
| 레지스터 | SR 래치를 기반으로 한 데이터 임시 저장 구조 |
| 명령어 집합 | 하드웨어와 소프트웨어 간 인터페이스 구조 |
| 클럭 신호 | CPU 동작 타이밍을 제어하는 신호 구조 |
| 스케줄링 | 프로세스 관리 및 유휴 상태 제어 구조 |
| 2의 보수 | 효율적 음수 표현을 위한 이진 연산 구조 |
| 파이프라인 | 병렬 명령어 처리를 위한 실행 구조 |
| 분기 예측 | 조건 분기 시 성능 최적화를 위한 추론 구조 |