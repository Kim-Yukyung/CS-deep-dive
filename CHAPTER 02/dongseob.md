# 🧠 운영체제, 프로세스, 스레드 근본 개념

CPU는 스레드, 프로세스, 운영 체제를 모르며 사실상 아래 두 가지밖에 모름 ㅇㅇ 

1. 메모리에서 명령어를 하나 가져온다.  
2. 이 명령어를 실행한 후 다시 “1”로 돌아간다.

---

## 레지스터(Register)와 프로그램 카운터(PC)

- **레지스터(Register)** : CPU 내부의 아주 빠르고 작은 메모리
  데이터를 임시로 저장하거나 연산 시 사용됨

- **프로그램 카운터(PC)** : CPU가 다음에 실행할 명령어의 주소를 저장
  일반적으로 명령어 실행이 끝나면 PC 값이 자동으로 1 증가하지만,  
  조건문이나 함수 호출 같은 제어 흐름 명령을 만나면  
  PC 값이 변경되어 다른 주소로 “점프”
  → 이 과정을 통해 CPU는 프로그램의 **실행 흐름을 제어**함

---

## 프로세스(Process)

프로그램이 실행되기 전까지는 단지 **디스크 위의 정적인 파일**
(소스 파일 → 컴파일러 → 실행 파일 → 디스크 저장 상태)

하지만 **실행**되면 운영체제가 실행 파일을 메모리에 적재(load)하고  
실행 상태를 관리하기 위해 **프로세스(Process)** 라는 단위를 만듬

> **즉, 프로그램이 실행된 순간 “프로세스”가 됨!!**

---

## 멀티태스킹(Multi Tasking) & 상황 정보(Context)

이전에는 한 번에 하나의 프로그램만 실행 가능했지만,  
지금의 운영체제는 **CPU가 매우 빠르게 여러 프로세스를 번갈아 실행**함으로써  
마치 여러 프로그램이 동시에 동작하는 것처럼 보임
→ 이를 **멀티태스킹(Multitasking)** 이라 함!

이를 위해 운영체제는 각 프로세스의 **상황 정보(Context)** 를 저장

- 현재 실행 중인 명령어 주소 (PC 레지스터 값)  
- 레지스터 값  
- 메모리 상태 등

---

## 프로세스의 메모리 구조 & 다중 프로세스

### 프로세스의 메모리 구조

| 영역 | 설명 |
|------|------|
| 코드(Code) | 실행할 기계어 명령어 |
| 데이터(Data) | 전역 변수, 정적 변수 |
| 힙(Heap) | 동적 할당 영역 (`malloc`, `new`) |
| 스택(Stack) | 함수 호출, 지역 변수 저장 공간 |

### 다중 프로세스와 한계

프로세스 간에는 **메모리 공간이 완전히 분리**되어 있음 
즉, 프로세스 A가 프로세스 B의 변수에 직접 접근할 수 없음..!!

→ 이런 **독립성 덕분에 안정성은 높지만**,  
프로세스 간 통신은 복잡하고 비용이 크며 **오버헤드 존재**

---

## 스레드(Thread)

프로세스 내부에서 실제로 **CPU가 실행하는 최소 단위**
즉, CPU가 직접 실행하는 것은 프로세스가 아니라 **“스레드”** 임!!

하나의 프로세스 안에 여러 개의 스레드를 둘 수 있으며,  
모든 스레드는 **코드·데이터·힙 영역을 공유**하지만  
**스택과 레지스터는 각각 독립적**으로 가짐

### 스레드의 특징

- 생성/종료 속도가 빠름 → *경량 프로세스 (Lightweight Process)*  
- 메모리 공유가 쉬워 통신이 빠름  
- 하지만 **공유 자원 접근 시 동기화 문제** 발생  
  (`race condition`, `deadlock` 등)

---

## 스레드의 수명 주기

### 긴 작업 (Long-Lived Thread)
- 실행 시간이 길고 특정 역할을 전담하는 스레드  
- **예:** Word의 “자동 저장” 스레드  
  - Word 프로세스 실행 시 스레드 생성  
  - Word 종료 시 함께 종료  
  - 프로세스 수명과 동일

### 짧은 작업 (Short-Lived Thread)
- 실행 시간이 매우 짧고 요청이 많음  
- “요청당 스레드” 방식은 오버헤드가 큼 → **스레드 풀(Thread Pool)** 사용

---

## 스레드 풀(Thread Pool)

- 스레드를 **미리 여러 개 만들어 두고**, 작업 요청이 들어오면 재사용  
- 스레드 생성/소멸 비용을 줄이고, 메모리 낭비 방지  
- 작업은 일반적으로 **큐(Queue)** 를 통해 전달됨

### 🔹 동작 구조
1. 스레드들이 작업 대기열(Queue)에서 **대기 (Blocking)**  
2. 생산자가 작업을 추가하면 스레드가 **깨어남**  
3. 작업을 가져와 처리한 뒤 **다시 대기 상태로 복귀**

> ⚠️ 스레드 수가 너무 적으면 CPU 활용률이 낮아지고,  
> 너무 많으면 오히려 성능 저하 및 메모리 낭비 발생.  
> → **CPU 집약적 작업**과 **I/O 집약적 작업**에 따라 최적 스레드 수가 달라짐

---

## CPU vs I/O 집약적 작업 비교

| 구분 | 설명 | 예시 | 적정 스레드 수 |
|------|------|------|----------------|
| **CPU 집약적** | 대부분 연산에 시간 소비 | 행렬 연산, 이미지 처리 | CPU 코어 수와 비슷하게 |
| **I/O 집약적** | 입출력 대기 시간이 많음 | 네트워크, 디스크 I/O | CPU 코어 수보다 많게 |
