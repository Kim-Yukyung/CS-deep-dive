### CPU의 명령어 처리 과정

**기본 흐름**
1. 명령어 가져오기 (Fetch)
	CPU는 메모리에서 명령어를 하나 읽어옵니다.
2. 명령어 실행 (Execute)
	가져온 명령어를 해석하고 실행한 뒤, 다시 다음 명령어를 가져오기 위해 1로 돌아갑니다.

- CPU는 **Program Counter(PC) 라는 레지스터를 기준**으로 어느 메모리 주소에서 명령어를 가져올지 결정합니다.

**기본 동작**
- 명령어를 실행할 때마다 PC 값이 자동으로 +1 증가하여 다음 명령어를 가리킵니다.

**제어 흐름 명령어**
- if, else, 함수 호출 등 분기나 점프가 필요한 명령어를 만나면, CPU가 직접 PC 값을 다른 주소로 변경하여 조건에 맞는 코드로 이동합니다.

**❕ 요약**

CPU가 프로그램을 실행하려면 실행 파일을 메모리에 적재하고, main 함수의 첫 번째 명령어 주소를 찾아
그 주소를 PC 레지스터에 저장합니다. 이후 PC를 기준으로 명령어를 순차적으로 가져와 실행합니다.

<br>

### 프로세스 주소 공간 (Process Address Space)

운영체제는 실행 중인 프로그램을 독립된 메모리 공간 안에서 관리합니다. 즉, 각 프로세스는 자신만의 "주소 공간"을 가지며, 다른 프로세스의 메모리에 접근할 수 없습니다. 

- 코드 영역: 프로그램의 기계어 명령어가 저장되는 공간
- 데이터 영역: 전역 변수와 static 변수가 저장되는 공간
- 힙 영역: 실행 중에 동적으로 메모리를 할당하는 영역 (malloc, new)
- 스택 영역: 함수 호출 시 생성되는 지역 변수와 매개변수 저장 공간

<br>

### 다중 프로세스 프로그래밍

- 하나의 프로그램이 여러 개의 프로세스 를 만들어 각각 독립적으로 실행하고, 결과를 서로 주고받으며 작업을 수행하는 방식
- 예를 들어, 프로세스 A는 데이터를 입력받고, 프로세스 B는 그 결과를 계산한 뒤, 다시 A로 결과를 전달해 다음 연산을 수행

**단점**
- 프로세스를 새로 생성할 때마다 별도의 메모리 공간과 자원이 필요함
- 프로세스마다 주소 공간이 독립적이므로, 데이터를 주고받기 위해 IPC 구현이 필요함
- 모든 프로세스는 main() 함수에서만 시작되므로, 하나의 CPU에서는 한 번에 하나의 명령어 흐름만 수행 가능

**해결 - 공유 프로세스 (멀티스레드)**

PC 레지스터가 main() 함수뿐 아니라 다른 함수도 가리킬 수 있다면, 한 프로세스 내부에서 여러 실행 흐름을 만들 수 있습니다. 

<br>

### 스레드 (Thread)

스레드는 프로세스 내에서 실행되는 독립적인 실행 흐름입니다. 즉, 하나의 프로세스 안에서 여러 스레드가 코드·데이터·힙 영역을 공유하면서 각자 다른 명령어 흐름을 동시에 실행할 수 있습니다.

**특징**
1. CPU의 기본 단위는 스레드
	CPU는 명령어를 실행할 때 스레드를 인식하지 않고, 단순히 PC 레지스터가 가리키는 주소의 명령어를 실행합니다. 따라서 스레드를 실행하려면, PC 레지스터를 스레드의 진입 함수 주소로 설정해야 합니다.
2. 스레드별 스택 영역 필요
	함수 실행에 필요한 정보는 스택 프레임에 저장됩니다. 따라서 프로세스의 주소 공간 안에 스레드마다 독립적인 스택 영역이 존재해야 합니다.

**문제**

CPU는 스레드 간의 관계나 동시 실행을 고려하지 않으므로, 여러 스레드가 동시에 공유 자원에 접근하면 충돌이 발생할 수 있습니다. 이를 해결하기 위해 다음과 같은 제어 기법이 필요합니다.

- 상호 배제 (Mutual Exclusion) : 한 번에 하나의 스레드만 자원 접근 허용
- 동기화 (Synchronization) : 스레드 간 실행 순서를 조정하여 일관성 유지

<br>

### 스레드 풀(Thread Pool)

작업이 들어올 때마다 새 스레드를 생성/종료하는 것은 오버헤드가 큽니다. 이를 해결하기 위해 미리 여러 개의 스레드를 만들어 두고, 작업이 들어오면 대기 중인 스레드가 즉시 처리하는 구조입니다.

**동작 방식**
1. 여러 개의 스레드를 미리 생성
2. 각 스레드는 작업 대기열(queue) 에서 대기
3. 생산자(producer)가 작업을 대기열에 추가
4. 스레드가 깨어나서 작업 구조체를 꺼내 처리
```c
struct task {
	void* data; // 작업이 처리할 데이터
	handler handle; // 데이터 처리 함수
}
```

<br>

### 스레드 전용 리소스

스레드는 같은 프로세스의 자원을 공유하지만, 실행 상태를 저장하는 정보(context)는 스레드마다 독립적입니다.

**스레드 상황 정보(Thread Context)**
- 스택 프레임 (매개변수, 지역 변수, 반환 주소)
- PC 레지스터 (다음에 실행될 명령어 주소)
- 스택 포인터 (Stack Pointer)
- 레지스터 집합 (CPU 내부 상태 정보)
-> 스레드 간에는 서로의 컨텍스트를 직접 접근할 수 없습니다.

**스레드 전용 저장소**

스레드별로 변수를 따로 유지할 수 있는 저장소로, 전역 변수를 스레드마다 복사본 형태로 보관할 수 있습니다.
→ 다른 스레드와 간섭 없이 독립적으로 데이터 사용 가능

<br>

### 스레드 안전

- 어떤 코드가 여러 스레드에 의해 동시에 호출되어도 항상 올바른 결과를 내면 그 코드를 스레드 안전하다고 말합니다.
- 스레드는 힙과 데이터 영역을 공유하므로,공유 리소스 접근 시 충돌(Race Condition) 이 발생할 수 있습니다.

**스레드 안전을 위한 설계 방법**
- 스레드 전용 저장소: 전역 리소스를 스레드별로 분리하여 각 스레드가 독립적으로 사용 (스레드 전용 저장소)
- 읽기 전용 접근: 전역 데이터를 변경하지 않고 읽기만 수행
- 원자성 연산: 연산이 도중에 중단되지 않고 한 번에 완료되도록 보장
- 동기화: 여러 스레드가 공유 자원에 접근할 때 순서와 상호 배제를 보장

**동기화(상호 배제) 기법**
- 뮤텍스: 한 번에 하나의 스레드만 접근 허용 (Lock / Unlock)
- 스핀락: 잠금이 해제될 때까지 루프를 돌며 대기 (짧은 대기 시간에 유용)
- 세마포어: 접근 가능한 스레드 수를 제한 (n개까지 허용 가능)

<br>

### 코루틴 (Coroutine)

코루틴은 자신의 실행 상태를 저장하고 일시 중지·재개할 수 있는 실행 단위입니다. 즉, 한 번 반환된 이후에도 마지막으로 중단된 지점에서 다시 이어서 실행할 수 있습니다.


**특징**
- 스레드와 달리 운영체제의 개입 없이 사용자 공간에서 실행됨
- 실행 중인 레지스터 상태, 스택 프레임 정보 등을 저장했다가 다시 복원 가능
- 힙 영역에 자신만의 실행 스택 프레임을 저장할 수 있음
- 전환 비용이 매우 적음
- 이론적으로 개수 제한이 없음 (메모리만 충분하다면 무한히 생성 가능)

<br>

### 콜백 함수

콜백 함수는 다른 코드(함수, 스레드, 모듈 등)에 매개변수로 전달되어 실행되는 함수입니다. 즉, 어떤 이벤트나 작업이 끝난 뒤 "나중에 불릴 함수" 입니다.

```c
#include <stdio.h>

// 콜백 함수 정의
void print_result(int result) {
    printf("결과: %d\n", result);
}

// 콜백 함수를 매개변수로 받는 함수
void calculate(int a, int b, void (*callback)(int)) {
    int sum = a + b;
    // 작업 완료 후 콜백 함수 호출
    callback(sum);
}

int main() {
    // print_result 함수를 콜백으로 전달
    calculate(3, 5, print_result);
    return 0;
}
```

**특징**
- 함수 자체를 인자로 전달할 수 있음
- 동기 호출 : 함수가 반환될 때까지 호출자가 대기
- 비동기 호출: 호출자는 대기하지 않고 다른 작업 수행

**단점**

콜백이 여러 번 중첩되면 콜백 지옥(Callback Hell) 발생

<br>

### 동기와 비동기

- 블로킹(Blocking) : 함수를 호출한 후, 결과가 반환될 때까지 호출자가 대기하는 방식
- 논블로킹(Non-Blocking) : 함수를 호출한 후, 결과를 기다리지 않고 다른 작업을 계속 수행하는 방식

**비동기 호출 시 결과를 확인하는 방법**
1. 호출자가 실행 결과를 신경 쓰지 않을 때: 콜백 함수 사용 → 결과가 준비되면 지정된 콜백 실행
2. 호출자가 실행 결과를 반드시 알아야 할 때: 알림 → 작업이 완료되면 호출자에게 신호나 메시지를 보냄

<br>

### 블로킹과 논블로킹

- 블로킹: 함수가 호출될 때, 호출한 스레드나 프로세스가 해당 함수의 작업이 끝날 때까지 일시 중지되는 방식 → CPU는 그동안 다른 일을 할 수 없음
- 논블로킹: 함수 호출 후 즉시 반환되어 호출자가 계속 자신의 작업을 수행할 수 있는 방식 → 작업의 완료 여부는 이후에 따로 확인하거나 알림으로 전달받음

✅ '동기/비동기'는 관계 개념, '블로킹/논블로킹'은 실행 방식 개념

블로킹 핵심은 스레드 또는 프로세스가 일시 중지되는 것이고, 모든 함수가 블로킹되는 것은 아님

```c
int sum(int a, int b) {
	return a+b;
}

void func() {
	int r = sum(1, 1);
}
```

**논블로킹에서 결과 확인 방법**
1. 폴링: 주기적으로 끝났는지 확인하는 함수 호출
2. 알림: 완료 시 OS나 스레드가 신호, 메시지 등으로 알려줌
3. 콜백 함수: 미리 전달한 함수를 완료 시 호출

‼️ 논블로킹이라고 해서 항상 비동기인 것은 아님 → 폴링 구조는 비동기가 아님

<br>

### 높은 동시성과 고성능을 갖춘 서버 구현

1. 다중 프로세스
	- 하나의 부모 프로세스가 여러 개의 자식 프로세스를 생성하여 각각 독립적으로 요청을 처리하는 방식
	- 리눅스에서는 부모 프로세스가 사용자 요청을 받고 fork()로 자식 프로세스 생성 → 요청 처리
	- 각 프로세스는 독립된 메모리 사용 → 안정적
	- 단점: 생성·종료 비용 크고, 프로세스 간 통신 부담 큼

2. 다중 스레드
	- 하나의 프로세스 내부에서 여러 스레드가 메모리 자원을 공유하며 동시에 작업 수행
	- 장점: 빠른 통신, 자원 공유 효율 높음
	- 단점: 한 스레드 오류 시 전체 프로세스 종료 위험, 동기화 문제 발생 가능

3. 이벤트 순환과 이벤트 구동
	- 이벤트 기반 동시성 모델: 이벤트가 도착하면 이벤트 유형을 확인하고 해당 이벤트 핸들러 실행
	- 문제 1: "하나의 함수로 여러 이벤트를 어떻게 감시할까?" → 입출력 다중화(I/O Multiplexing) (select, poll, epoll)로 해결
	- 문제 2: "이벤트 핸들러는 반드시 같은 스레드에서 실행되어야 할까?" → 이벤트 루프 + 다중 스레드 결합으로 해결
